<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Dlm (dlm.Dlm)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="generator" content="doc-ock-html v1.0.0-1-g1fc9bf0"/></head><body><nav id="top"><a href="../index.html">Up</a> &mdash; <span class="package">package <a href="../index.html">dlm</a></span></nav><header><h1><span class="keyword">Module</span> <span class="module-path">Dlm</span></h1></header><p>OCaml bindings for <code class="code">libdlm(3)</code>.</p><p><em>v0.3.0 - <a href="https://github.com/xapi-project/ocaml-dlm/">homepage</a></em>.</p><p>All operations require <code class="code">DLM</code> (Linux Distributed Lock Manager) to be running.</p><p>Consult the <a href="index.html#lockspaces">lockspaces</a>, and <a href="index.html#locks">locks</a> documentation or
read the <a href="index.html#example">example</a>.</p><h4>References.</h4><ul><li><em><a href="http://people.redhat.com/ccaulfie/docs/rhdlmbook.pdf">Programming Locking Applications.</a></em></li></ul><h2 id="lockspaces" class="anchored"><a href="#lockspaces" class="anchor"></a>Lockspaces</h2><p>Lockspaces are identified by a cluster-wide name, they are intended as
private namespaces for locks belonging to a single application.</p><div class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>t</code><code></code><code></code></div><div class="doc"><p>the type of a DLM lockspace</p></div></div><div class="spec val" id="val-join"><a href="#val-join" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>join : ?&#8288;mode:PosixTypes.mode_t <span class="keyword">&#8209;&gt;</span> string <span class="keyword">&#8209;&gt;</span> unit Lwt.t</code></div><div class="doc"><p><code class="code">join ?mode lockspace</code> creates and joins the specified <code class="code">lockspace</code>
on the current node.</p><p>Requires CAP_SYSADMIN privileges, access to the created lockspace is
controlled by <code class="code">mode</code>.</p><ul class="at-tag"><li><span class="at-tag raise">Raises</span> <span class="module-path">Unix.Unix_error</span>: on failure</li></ul></div></div><div class="spec val" id="val-leave"><a href="#val-leave" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>leave : ?&#8288;force:bool <span class="keyword">&#8209;&gt;</span> string <span class="keyword">&#8209;&gt;</span> unit Lwt.t</code></div><div class="doc"><p><code class="code">leave ?force lockspace</code> leaves the specified <code class="code">lockspace</code> on the current node.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">force</span>: will leave the lockspace even if the current node has active locks</li></ul></div></div><div class="spec val" id="val-with_lockspace"><a href="#val-with_lockspace" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>with_lockspace : string <span class="keyword">&#8209;&gt;</span> f:(<a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> Lwt.t) <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> Lwt.t</code></div><div class="doc"><p><code class="code">with_lockspace lockspace ~f</code> opens an existing <code class="code">lockspace</code>,
calls <code class="code">f t</code> with the lockspace handle <code class="code">t</code>, and closes the lockspace
after <code class="code">f</code> terminates.
The lockspace is also automatically closed on process exit.</p></div></div><h2 id="locks" class="anchored"><a href="#locks" class="anchor"></a>Locks</h2><p>Locks are a named cluster-wide resource inside a specific <a href="index.html#lockspaces">lockspace</a>.</p><p>Only a simplified interface is provided that acquires a lock, performs an operation and releases it.
Locking can be nested, even with same lock name, but note that trying to acquire an exclusive lock twice will fail.</p><p>It is recommended to use the <a href="index.html#type-mode.LKM_PRMODE">LKM_PRMODE</a> mode for reading and <a href="index.html#type-mode.LKM_EXMODE">LKM_EXMODE</a> for writing.</p><div class="spec type" id="type-mode"><a href="#type-mode" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>mode</code><code></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-mode.LKM_NLMODE" class="anchored"><td class="def constructor"><a href="#type-mode.LKM_NLMODE" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">LKM_NLMODE</span></code></td><td class="doc"><p>(** null lock - just allocate the lock, used internally by <a href="index.html#val-with_lock">with_lock</a> *)</p></td></tr><tr id="type-mode.LKM_CRMODE" class="anchored"><td class="def constructor"><a href="#type-mode.LKM_CRMODE" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">LKM_CRMODE</span></code></td><td class="doc"><p>(** concurrent read - read while others can read/write. *)</p></td></tr><tr id="type-mode.LKM_CWMODE" class="anchored"><td class="def constructor"><a href="#type-mode.LKM_CWMODE" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">LKM_CWMODE</span></code></td><td class="doc"><p>(** concurrent write - read/write while others can read/write. *)</p></td></tr><tr id="type-mode.LKM_PRMODE" class="anchored"><td class="def constructor"><a href="#type-mode.LKM_PRMODE" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">LKM_PRMODE</span></code></td><td class="doc"><p>(** protected read - read, while others can only read. *)</p></td></tr><tr id="type-mode.LKM_PWMODE" class="anchored"><td class="def constructor"><a href="#type-mode.LKM_PWMODE" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">LKM_PWMODE</span></code></td><td class="doc"><p>(** protected write - read/write, while others can only read *)</p></td></tr><tr id="type-mode.LKM_EXMODE" class="anchored"><td class="def constructor"><a href="#type-mode.LKM_EXMODE" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">LKM_EXMODE</span></code></td><td class="doc"><p>(** exclusive - exclusive read/write, others have no access *)</p></td></tr></table><code></code></div><div class="doc"><p>lock mode</p></div></div><div class="spec val" id="val-with_lock"><a href="#val-with_lock" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>with_lock : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;mode:<a href="index.html#type-mode">mode</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;try_:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;timeout:float <span class="keyword">&#8209;&gt;</span> string <span class="keyword">&#8209;&gt;</span> f:(unit <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> Lwt.t) <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> Lwt.t</code></div><div class="doc"><p><code class="code">with_lock lshandle ?mode ?try_ ?timeout lockname ~f</code>
acquires <code class="code">lockname</code> in lock<code class="code">mode</code> and calls <code class="code">f</code> when the lock is acquired.
Releases the lock after <code class="code">f</code> terminates.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">mode</span>: lock mode defaults to <a href="index.html#type-mode.LKM_EXMODE">LKM_EXMODE</a></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">timeout</span>: specifies how long to wait for the lock to be acquired</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">try_</span>: fail with EAGAIN if the lock cannot be granted immediately</li><li><span class="at-tag raise">Raises</span> <span class="module-path">Unix.Unix_error</span>: if the lock cannot be granted</li></ul></div></div><h2 id="example" class="anchored"><a href="#example" class="anchor"></a>Example</h2><p>Need to be run as root, and with a working <code class="code">DLM</code>.
You can use <code class="code">dlm_tool status</code> to check for a working <code class="code">DLM</code>.
</p><pre><code class="code">
     #use &quot;topfind&quot;;;
     #require &quot;dlm&quot;;;
     open Lwt.Infix;;

     let lockspace = &quot;myapp&quot; in
     Dlm.join lockspace &gt;&gt;= fun () -&gt;
     Dlm.with_lockspace lockspace (fun ls -&gt;
         Dlm.with_lock ls &quot;mylock1&quot; ~f:(fun () -&gt;
             (* acquired exclusive lock *)
             Lwt.return_unit
           ) &gt;&gt;= fun () -&gt;
         Dlm.with_lock ~mode:Dlm.LKM_PRMODE ls &quot;mylock1&quot; ~f:(fun () -&gt;
             (* acquired shared read lock *)
             Lwt.return_unit
           )
       ) &gt;&gt;= fun () -&gt;
     Dlm.leave lockspace
   </code></pre></body></html>